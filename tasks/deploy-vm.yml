---
- name: Check if qcow OS image template exist
  stat:
    path: "{{ os_qcow_template }}"
  register: cloud_init_image_exist

- name: Copy cloud-init user data
  template: 
    src: user-data.j2 
    dest: "{{ cloud_init_user_data }}"
    mode: 0777
  register: cloud_intit_user_data

- name: Generate cloud-init meta data
  copy:
    dest: "{{ cloud_init_meta_data }}"
    content: |
      instance-id: {{ vm_name }}
      hostname: {{ vm_hostname }}
      local-hostname: {{ vm_local_hostname }}

- name: Create operating system disk for vm
  command: "qemu-img create -f qcow2 {{ os_disk }} {{ vm_root_disk_size }}"
  args:
    creates: "{{ os_disk }}"
  register: os_disk_results
  when: vm_name not in all_instances.list_vms

- name: Verify operating system disk for vm exists
  stat:
    path: "{{ os_disk }}"
  register: os_disk_created

- name: get operating system disk virtual size
  shell: >
    qemu-img info "{{ os_disk }}" | awk '/disk size/ {print $3}'
  register: os_virtual_disk_size
  changed_when: false

- name: set os disk size to human readable format
  set_fact:
    os_disk_size: "{{ os_virtual_disk_size.stdout | human_to_bytes }}"
  when: os_disk_created.stat.exists

# TODO: add play to exit if OS disk could not be found

- name: Push base image onto vm operating system disk
  command: >
    virt-resize --expand /dev/sda1 "{{ os_qcow_template }}" "{{ os_disk }}"
  register: resize_os_disk_results
  changed_when: '"Resize operation completed with no errors" in resize_os_disk_results.stdout'
  when: os_disk_created.stat.exists and os_disk_size|int < '1073741824'|int

- name: Grow root file system to size of disk
  command: "virt-customize -a {{ os_disk }} --run-command 'xfs_growfs /'"
  register: grow_os_disk_results
  changed_when: '"Finishing off" in grow_os_disk_results.stdout'
  when: os_disk_created.stat.exists and os_disk_size|int < '1073741824'|int

- name: Set the root password for the vm
  command: > 
    virt-customize -a {{ os_disk }} --root-password password:{{ kvm_vm_root_pwd }}
  register: mod_os_disk_results
  changed_when: '"Finishing off" in mod_os_disk_results.stdout'
  when: grow_os_disk_results.changed

- name: Save resolv.conf to local filesystem
  template:
    src: resolv.conf.j2
    dest: "{{ vm_resolv_conf }}"
  when: grow_os_disk_results.changed

- name: Copy resolv conf file into vm operating disk
  command: >
    virt-copy-in -a {{ os_disk }}
    {{ vm_resolv_conf }} /etc/
  changed_when: false
  when: grow_os_disk_results.changed

- name: check for existing cloud init iso
  stat:
    path: "{{ cloud_init_iso_image }}"
  register: cloud_init_iso
    
- name: Create iso image for cloud init
  shell: "genisoimage -output {{ cloud_init_iso_image }} -volid cidata -joliet -r {{ cloud_init_user_data }} {{ cloud_init_meta_data }}"
  when: cloud_intit_user_data.changed or cloud_init_iso.stat.exists == False

- name: generate virt-install command arguments
  template: 
    src: virt-install-cmd.j2
    dest: "{{ vm_virtinstall_script }}"
    mode: 0755

- name: deploy VM instance
  #command: "/var/lib/vmdata/{{ vm_name }}/virtinstall.sh"
  command: "{{ vm_virtinstall_script }}"
  when: vm_name not in all_instances.list_vms
  register: deploy_vm
  failed_when: "('Domain installation does not' in deploy_vm.stderr) or
                ('failed to' in deploy_vm.stderr) or
                ('ERROR' in deploy_vm.stderr)"
- debug:
    msg: "{{ deploy_vm }}"
    verbosity: 2

- name: copy script to KVM host
  copy:
    src: "files/{{ item }}"
    dest: "/usr/local/bin/{{ item }}"
    mode: 755
    owner: root
  with_items:
    - getvmip
    - attach-libvirt-disk

- name: create extra qcow disk
  vars:
    disk_name: "{{ extra_disk_name }}_vd{{ disk_sequence[item | int + count ] }}.qcow2"
    disk_opt: "cluster_size=128K"
  command: >
    qemu-img create -f qcow2 -o "{{ disk_opt }}" "{{ disk_name }}" "{{ item.size }}"
  args:
    creates: "{{ disk_name }}"
  loop: "{{ extra_storage }}"
  loop_control:
    index_var: count
    label: "{{ disk_name }}"
  when: item.enable
  register: extra_disk_created

- debug:
    msg: "{{ extra_disk_created }}"
    verbosity: 2

- name: Attach External Disk
  vars:
    disk_name: "{{ extra_disk_name }}_vd{{ disk_sequence[item | int + count ] }}.qcow2"
    disk: "vd{{ disk_sequence[item | int + count ] }}"
  command: >
    /usr/local/bin/attach-libvirt-disk "{{ vm_name }}" "{{ disk_name }}" "{{ disk }}"
  register: attached_disk
  loop: "{{ extra_storage }}"
  loop_control:
    index_var: count
    label: "{{ disk_name }}"
  when: item.enable
  changed_when: '"Disk attached successfully" in attached_disk.stdout'

# TODO: move the mac and bridge device task to the getvmip script
- name: Get MAC address
  shell: >
     virsh --connect qemu:///system dumpxml {{ vm_name }} | awk -F\' '/mac address/ {print $2}'
  delegate_to: "{{ kvm_install_host }}"
  register: mac_info
  changed_when: false

- name: Gather bridge device name
  shell: >
    virsh --connect qemu:///system net-info {{ vm_libvirt_net }}|grep Bridge|awk '{print $2}'
  delegate_to: "{{ kvm_install_host }}"
  register: vm_libvirt_net_dev_name
  changed_when: false

- name: Gather IP address of the VM and handle errors
  block:
    - name: get VM ip
      command: "/usr/local/bin/getvmip -r {{ vm_name }}"
      until: vm_ip.stdout != ""
      retries: 30
      delay: 1
      register: vm_ip
      changed_when: False
  rescue:
    - debug:
        msg: "could not get ip for a vm"

- name: Get VM Netmask prefix
  shell: |
    /usr/local/bin/getvmip -a| awk -F'/' '/{{ vm_name }}/ {print $2}'
  register: vm_netmask_prefix
  when: vm_ip.stdout != ""
  changed_when: False

- name: Get VM nic device
  shell: |
    /usr/local/bin/getvmip -a| awk '/{{ vm_name }}/ {print $3}'
  register: vm_nic
  when: vm_ip.stdout != ""
  changed_when: False

#- name: Copy ifcfg-{{ vm_nic.stdout }} to VM
#  command: >
#    virt-copy-in -a {{ os_disk }}
#    {{ vm_ifcfg_file }} /etc/sysconfig/network-scripts/
#  changed_when: false
#  when: grow_os_disk_results.changed

- name: Check if cd-rom is attached
  shell: >
    virsh domblklist "{{ vm_name }}" | grep "{{ cidata_iso_name }}"|cat
  register: check_cdrom
  changed_when: false

- name: Eject CD-Rom
  shell: "virsh change-media {{ vm_name }} {{ check_cdrom.stdout.split()[0] }} --eject"
  when: check_cdrom.stdout != ""

#- name: update inventory
#  lineinfile:
#    path: "{{ inventory_file }}"
#    line: "{{ vm_name }}   ansible_host={{ vm_ip.stdout }} ansible_user={{ admin_user }}"
#    state: present
#  register: update_inventory
##  when: update_inventory
#
#- name: refresh local static inventory
#  meta: refresh_inventory
#
#- name: Deploy ifcfg-{{ vm_nic.stdout }} to VM
#  template:
#    src: ifcfg.j2
#    dest: "/etc/sysconfig/network-scripts/ifcfg-{{ vm_nic.stdout }}"
#  delegate_to: "{{ vm_name }}"
#  when: vm_ip.stdout != ""
#  #when: vm_ip.stdout != "" and update_inventory.changed
#
#- name: ensure cloud-init is removed
#  yum:
#    name: cloud-init
#    state: absent
#  delegate_to: "{{ vm_name }}"
#  when: vm_ip.stdout != ""
#  
